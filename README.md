# Библиотека Матриц - s21_matrix.a

## Введение

Матрица — это прямоугольная таблица чисел, организованная в строки и столбцы. Данная библиотека предоставляет набор функций для выполнения основных операций с матрицами, таких как создание, сложение, вычитание, умножение и другие. Библиотека написана на языке C, соответствует стандарту C11 и компилируется с использованием `gcc`. Она разработана для обеспечения надежности, эффективности и легкости интеграции в различные проекты, требующие выполнения матричных вычислений.

## Представление матрицы в C

В данной библиотеке матрица представлена следующей структурой:

```c
typedef struct matrix_struct {
    double** matrix;  // Указатель на элементы матрицы
    int rows;         // Количество строк в матрице
    int columns;      // Количество столбцов в матрице
} matrix_t;
```

# Операции над матрицами

## Создание матрицы

Функция `s21_create_matrix` создает матрицу заданного размера и инициализирует ее элементы.

```c
int s21_create_matrix(int rows, int columns, matrix_t *result);
```

**Возвращаемые значения:**

- `0` — OK;
- `1` — Ошибка, некорректная матрица (недопустимые размеры или ошибка выделения памяти).

## Очистка матрицы

Функция `s21_remove_matrix` освобождает память, занятую матрицей.

```c
void s21_remove_matrix(matrix_t *A);
```

## Сравнение матриц

Функция `s21_eq_matrix` сравнивает две матрицы. Матрицы считаются равными, если они имеют одинаковые размеры и соответствующие элементы равны с точностью до 7 знака после запятой.

```c
#define SUCCESS 1
#define FAILURE 0

int s21_eq_matrix(matrix_t *A, matrix_t *B);
```

## Сложение и вычитание матриц

Функции `s21_sum_matrix` и `s21_sub_matrix` выполняют сложение и вычитание матриц соответственно. Обе матрицы должны иметь одинаковые размеры.

```c
int s21_sum_matrix(matrix_t *A, matrix_t *B, matrix_t *result);
int s21_sub_matrix(matrix_t *A, matrix_t *B, matrix_t *result);
```

### Сложение Матриц

Сложение двух матриц `A` и `B` того же размера приводит к новой матрице `C`, каждый элемент которой вычисляется как:
```
    C(i,j) = A(i,j) + B(i,j)
```

**Пример:**

Пусть матрицы A и B имеют следующие значения:

    A = [1  2
         3  4]

    B = [5  6
         7  8]

Тогда сумма матриц C будет:

    C = [1 + 5  2 + 6
         3 + 7  4 + 8]

    C = [6  8
         10 12]


### Вычитание Матриц

Вычитание одной матрицы `B` из другой матрицы `A` того же размера приводит к новой матрице `C`, каждый элемент которой вычисляется как:
```
    C(i,j) = A(i,j) - B(i,j)
```

***Пример***

Пусть матрицы A и B имеют следующие значения:

```
    A = [5  6
         7  8]

    B = [1  2
         3  4]
```

Тогда разность матриц C будет:

```
    C = [5 - 1  6 - 2
         7 - 3  8 - 4]

    C = [4  4
         4  4]
```


**Возвращаемые значения:**

```
- `0` — OK;
- `1` — Ошибка, некорректная матрица;
- `2` — Ошибка вычисления (размеры матриц не совпадают).
```

## Умножение Матрицы на Число

```c
int s21_mult_number(matrix_t *A, double number, matrix_t *result);
```

Умножение матрицы `A` размером `m x n` на число `k` приводит к новой матрице `B` размером `m x n`, каждый элемент которой вычисляется по формуле:

```
    B(i,j) = k * A(i,j)
```

где `B(i,j)` — элемент матрицы `B`, расположенный в строке `i` и столбце `j`.

**Пример:**

Пусть матрица `A` имеет следующие значения:

```
    A = [ [1, 2], 
          [3, 4] ]
```

Умножение матрицы `A` на число `3`:

```
    B = 3 * A
      = [ [3*1, 3*2], 
          [3*3, 3*4] ]
      = [ [3, 6], 
          [9, 12] ]
```

## Умножение Двух Матриц

```c
int s21_mult_matrix(matrix_t *A, matrix_t *B, matrix_t *result);
```

**Пример:**

Пусть матрицы `A` и `B` имеют следующие значения:

```
    A = [ [1, 4], 
          [2, 5], 
          [3, 6] ]

    B = [ [1, -1, 1], 
          [2,  3, 4] ]
```

Тогда произведение матриц `C` будет:

```
    C = [ [1*1 + 4*2, 1*(-1) + 4*3, 1*1 + 4*4], 
          [2*1 + 5*2, 2*(-1) + 5*3, 2*1 + 5*4], 
          [3*1 + 6*2, 3*(-1) + 6*3, 3*1 + 6*4] ]

    C = [ [9, 11, 17], 
          [12, 13, 22], 
          [15, 15, 27] ]
```

## Транспонирование матрицы (transpose)

```c
int s21_transpose(matrix_t *A, matrix_t *result);
```

Транспонирование матрицы А заключается в замене строк этой матрицы ее столбцами с сохранением их номеров.

```
          1 4   1 2 3
A = A^T = 2 5 = 4 5 6
          3 6
```

## Минор матрицы и матрица алгебраических дополнений (calc_complements)

```c
int s21_calc_complements(matrix_t *A, matrix_t *result);
```

Минор M(i,j) матрицы A — это определитель (n-1)-го порядка, полученный вычеркиванием i-й строки и j-го столбца.

Матрица алгебраических дополнений вычисляется как значения миноров, умноженные на (-1)^(i+j).

**Пример:**

Пусть матрица A имеет следующие значения:

```
    A = [1  2  3
         0  4  2
         5  2  1]
```

Минор элемента (1,1) будет:

```
    M(1,1) = [4  2
              2  1]

    |M(1,1)| = 4 - 4 = 0
```

Матрица миноров:

```
    M = [0 -10 -20
         -4 -14 -8
         -8  2   4]
```

Матрица алгебраических дополнений:

```
    M* = [ 0  10 -20
          -4 -14  8
           8 -2   4]
```

## Определитель матрицы (determinant)

```c
int s21_determinant(matrix_t *A, double *result);
```

Определитель (детерминант) — это число, которое ставят в соответствие каждой квадратной матрице и вычисляют из элементов по специальным формулам.

***определитель может быть вычислен только для квадратной матрицы.***

Определитель матрицы равен сумме произведений элементов строки (столбца) на соответствующие алгебраические дополнения.

Поиск определителя для матрицы A по первой строке:

**Пример:**

```
    1 2 3
A = 4 5 6
    7 8 9
	
    |A| = 1 × (5 × 9 - 6 × 8)
        - 2 × (4 × 9 - 6 × 7)
        + 3 × (4 × 8 - 5 × 7)

    |A| = 1 × (45 - 48)
        - 2 × (36 - 42)
        + 3 × (32 - 35)

    |A| = -3 + 12 - 9
    |A| = 0
```

## Обратная матрица (inverse_matrix)

```c
int s21_inverse_matrix(matrix_t *A, matrix_t *result);
```

Матрицу A в степени -1 называют обратной к квадратной матрице А, если произведение этих матриц равняется единичной матрице.

Обратной матрицы не существует, если определитель равен 0.

Обратная матрица находится по формуле $`A^{-1}=\frac{1} {|A|} × A_*^T`$

Дана матрица:

```
     2  5  7
A =  6  3  4
     5 -2 -3
```

Поиск определителя:

``` |A| = -1 ```

Определитель |A| != 0 -> обратная матрица существует.

Построение матрицы миноров:

```
    -1 -38 -27
М = -1 -41 -29
    -1 -34 -24
```

Матрица алгебраических дополнений будет равна:

```
     -1  38 -27
М. =  1 -41  29
     -1  34 -24
```

Транспонированная матрица алгебраических дополнений будет равна:

```
        -1   1  -1
М^T. =  38 -41  34
       -27  29 -24
```

Обратная матрица будет иметь следующий вид:

```
                           1  -1   1
A^(-1) =  1/|A| * M^T. = -38  41 -34
                          27 -29  24 
```

## Задания

1. Реализуйте функции библиотеки s21_matrix.h, включая create_matrix, remove_matrix, eq_matrix, sum_matrix, sub_matrix, mult_number, mult_matrix, transpose, determinant, calc_complements, и inverse_matrix.
2. Библиотека должна быть разработана на языке C стандарта C11 и компилироваться с помощью gcc.
3. Организуйте код библиотеки в виде статической библиотеки с именем s21_matrix.a и заголовочным файлом s21_matrix.h.
4. Реализуйте unit-тесты с использованием библиотеки Check для покрытия не менее 80% кода.
5. Подготовьте Makefile для сборки библиотеки и тестов, включая цели all, clean, test, s21_matrix.a, и gcov_report.
6. В цели gcov_report должен формироваться отчет gcov в виде HTML страницы.

* Обратите внимание на необходимость соблюдения стандартов POSIX.1-2017 и избегайте устаревших и выведенных из употребления конструкций языка и библиотечных функций. Код должен соответствовать принципам структурного программирования и стиля Google.

## Принципы Структурного Программирования и Стиль Google

### Принципы Структурного Программирования

1. **Разделение на Функции**: Код должен быть разбит на маленькие, независимые функции, каждая из которых выполняет одну конкретную задачу. Это облегчает тестирование и поддержку кода.
   
2. **Минимизация Глобальных Переменных**: Глобальные переменные следует избегать. Используйте параметры функций и возвращаемые значения для передачи данных между функциями.

3. **Контроль Потока**: Используйте явные конструкции управления потоком (условные операторы, циклы) и избегайте использования "goto", чтобы обеспечить читаемость и предсказуемость кода.

4. **Модульность**: Разделяйте код на модули с четко определенными интерфейсами. Каждый модуль должен иметь ясную и ограниченную область ответственности.

5. **Документация**: Комментируйте код, объясняя сложные участки и цель каждой функции. Используйте четкие и информативные имена для функций и переменных.

### Стиль Кода Google

1. **Именование**:
   - Имена переменных, функций и типов данных должны быть ясными и описательными.
   - Используйте `snake_case` для именования переменных и функций.
   - Используйте `CamelCase` для именования типов данных и структур.

2. **Отступы и Форматирование**:
   - Используйте 2 пробела для отступов. Не используйте табуляцию.
   - Разделяйте логические блоки кода пустыми строками.
   - Помещайте открывающую фигурную скобку на той же строке, что и управляющая конструкция.

3. **Комментарии**:
   - Комментарии должны быть краткими и информативными.
   - Используйте комментарии для объяснения алгоритмов, не очевидных решений и важных частей кода.
   - Держите комментарии актуальными и синхронизированными с кодом.

4. **Возврат Значений**:
   - Все функции должны иметь явно определенный тип возвращаемого значения.
   - Если функция не возвращает значений, используйте тип `void`.

5. **Обработка Ошибок**:
   - Проверяйте ошибки на каждом этапе работы с матрицами.
   - Используйте код возврата для сигнализации об ошибках и корректно обрабатывайте их в вызывающем коде.

6. **Массивы и Указатели**:
   - При работе с массивами и указателями всегда учитывайте их размер и границы, чтобы избежать ошибок доступа к памяти.





